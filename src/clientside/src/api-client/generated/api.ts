/* tslint:disable */
/* eslint-disable */
/**
 * GitLabKit.Runner
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface AssemblyInfo
 */
export interface AssemblyInfo {
    /**
     * 
     * @type {string}
     * @memberof AssemblyInfo
     */
    'version': string | null;
}
/**
 * 
 * @export
 * @interface BulkRunnerActiveStatus
 */
export interface BulkRunnerActiveStatus {
    /**
     * 
     * @type {{ [key: string]: boolean; }}
     * @memberof BulkRunnerActiveStatus
     */
    'runners': { [key: string]: boolean; } | null;
}
/**
 * 
 * @export
 * @interface BulkRunnerDelete
 */
export interface BulkRunnerDelete {
    /**
     * 
     * @type {Array<number>}
     * @memberof BulkRunnerDelete
     */
    'runnerIds': Array<number> | null;
}
/**
 * 
 * @export
 * @interface Group
 */
export interface Group {
    /**
     * 
     * @type {number}
     * @memberof Group
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof Group
     */
    'name': string | null;
    /**
     * 
     * @type {string}
     * @memberof Group
     */
    'webUrl': string | null;
}
/**
 * 
 * @export
 * @interface Job
 */
export interface Job {
    /**
     * 
     * @type {number}
     * @memberof Job
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof Job
     */
    'status': string;
    /**
     * 
     * @type {string}
     * @memberof Job
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Job
     */
    'ref': string;
    /**
     * 
     * @type {string}
     * @memberof Job
     */
    'startedAt': string;
    /**
     * 
     * @type {number}
     * @memberof Job
     */
    'duration': number;
    /**
     * 
     * @type {string}
     * @memberof Job
     */
    'webUrl': string;
    /**
     * 
     * @type {string}
     * @memberof Job
     */
    'finishedAt'?: string | null;
    /**
     * 
     * @type {Project}
     * @memberof Job
     */
    'project': Project;
}
/**
 * 
 * @export
 * @interface ProblemDetails
 */
export interface ProblemDetails {
    [key: string]: any | any;

    /**
     * 
     * @type {string}
     * @memberof ProblemDetails
     */
    'type': string | null;
    /**
     * 
     * @type {string}
     * @memberof ProblemDetails
     */
    'title': string | null;
    /**
     * 
     * @type {number}
     * @memberof ProblemDetails
     */
    'status'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof ProblemDetails
     */
    'detail': string | null;
    /**
     * 
     * @type {string}
     * @memberof ProblemDetails
     */
    'instance': string | null;
}
/**
 * 
 * @export
 * @interface Project
 */
export interface Project {
    /**
     * 
     * @type {number}
     * @memberof Project
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof Project
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Project
     */
    'pathWithNamespace': string;
}
/**
 * 
 * @export
 * @interface Runner
 */
export interface Runner {
    /**
     * 
     * @type {number}
     * @memberof Runner
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof Runner
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof Runner
     */
    'ipAddress': string;
    /**
     * 
     * @type {boolean}
     * @memberof Runner
     */
    'active': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Runner
     */
    'online': boolean;
    /**
     * 
     * @type {string}
     * @memberof Runner
     */
    'contactedAt': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof Runner
     */
    'tagList': Array<string>;
    /**
     * 
     * @type {Array<Job>}
     * @memberof Runner
     */
    'currentJob': Array<Job>;
}

/**
 * GroupApi - axios parameter creator
 * @export
 */
export const GroupApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} groupId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroup: async (groupId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('getGroup', 'groupId', groupId)
            const localVarPath = `/group/{groupId}`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GroupApi - functional programming interface
 * @export
 */
export const GroupApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = GroupApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {number} groupId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGroup(groupId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Group>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGroup(groupId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * GroupApi - factory interface
 * @export
 */
export const GroupApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = GroupApiFp(configuration)
    return {
        /**
         * 
         * @param {number} groupId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroup(groupId: number, options?: any): AxiosPromise<Group> {
            return localVarFp.getGroup(groupId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * GroupApi - object-oriented interface
 * @export
 * @class GroupApi
 * @extends {BaseAPI}
 */
export class GroupApi extends BaseAPI {
    /**
     * 
     * @param {number} groupId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupApi
     */
    public getGroup(groupId: number, options?: AxiosRequestConfig) {
        return GroupApiFp(this.configuration).getGroup(groupId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * HealthCheckApi - axios parameter creator
 * @export
 */
export const HealthCheckApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersion: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/version`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        index: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/health`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * HealthCheckApi - functional programming interface
 * @export
 */
export const HealthCheckApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = HealthCheckApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVersion(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AssemblyInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getVersion(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async index(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.index(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * HealthCheckApi - factory interface
 * @export
 */
export const HealthCheckApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = HealthCheckApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersion(options?: any): AxiosPromise<AssemblyInfo> {
            return localVarFp.getVersion(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        index(options?: any): AxiosPromise<boolean> {
            return localVarFp.index(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * HealthCheckApi - object-oriented interface
 * @export
 * @class HealthCheckApi
 * @extends {BaseAPI}
 */
export class HealthCheckApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HealthCheckApi
     */
    public getVersion(options?: AxiosRequestConfig) {
        return HealthCheckApiFp(this.configuration).getVersion(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HealthCheckApi
     */
    public index(options?: AxiosRequestConfig) {
        return HealthCheckApiFp(this.configuration).index(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * RunnerApi - axios parameter creator
 * @export
 */
export const RunnerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {BulkRunnerDelete} [bulkRunnerDelete] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkDeleteRunner: async (bulkRunnerDelete?: BulkRunnerDelete, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/runner/bulk-delete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(bulkRunnerDelete, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {BulkRunnerActiveStatus} [bulkRunnerActiveStatus] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkSetRunnerActiveStatus: async (bulkRunnerActiveStatus?: BulkRunnerActiveStatus, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/runner/bulk`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(bulkRunnerActiveStatus, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} runnerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRunner: async (runnerId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'runnerId' is not null or undefined
            assertParamExists('deleteRunner', 'runnerId', runnerId)
            const localVarPath = `/runner/{runnerId}`
                .replace(`{${"runnerId"}}`, encodeURIComponent(String(runnerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} groupId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupRunners: async (groupId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('getGroupRunners', 'groupId', groupId)
            const localVarPath = `/runner/group/{groupId}`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} runnerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRunnerJobHistory: async (runnerId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'runnerId' is not null or undefined
            assertParamExists('getRunnerJobHistory', 'runnerId', runnerId)
            const localVarPath = `/runner/{runnerId}/history`
                .replace(`{${"runnerId"}}`, encodeURIComponent(String(runnerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} runnerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSingleRunner: async (runnerId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'runnerId' is not null or undefined
            assertParamExists('getSingleRunner', 'runnerId', runnerId)
            const localVarPath = `/runner/{runnerId}`
                .replace(`{${"runnerId"}}`, encodeURIComponent(String(runnerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} runnerId 
         * @param {boolean} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setRunnerActiveStatus: async (runnerId: number, body?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'runnerId' is not null or undefined
            assertParamExists('setRunnerActiveStatus', 'runnerId', runnerId)
            const localVarPath = `/runner/{runnerId}`
                .replace(`{${"runnerId"}}`, encodeURIComponent(String(runnerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RunnerApi - functional programming interface
 * @export
 */
export const RunnerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RunnerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {BulkRunnerDelete} [bulkRunnerDelete] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bulkDeleteRunner(bulkRunnerDelete?: BulkRunnerDelete, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bulkDeleteRunner(bulkRunnerDelete, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {BulkRunnerActiveStatus} [bulkRunnerActiveStatus] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bulkSetRunnerActiveStatus(bulkRunnerActiveStatus?: BulkRunnerActiveStatus, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bulkSetRunnerActiveStatus(bulkRunnerActiveStatus, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} runnerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteRunner(runnerId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteRunner(runnerId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} groupId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGroupRunners(groupId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Runner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGroupRunners(groupId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} runnerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRunnerJobHistory(runnerId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Job>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRunnerJobHistory(runnerId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} runnerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSingleRunner(runnerId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Runner>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSingleRunner(runnerId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} runnerId 
         * @param {boolean} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setRunnerActiveStatus(runnerId: number, body?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setRunnerActiveStatus(runnerId, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * RunnerApi - factory interface
 * @export
 */
export const RunnerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RunnerApiFp(configuration)
    return {
        /**
         * 
         * @param {BulkRunnerDelete} [bulkRunnerDelete] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkDeleteRunner(bulkRunnerDelete?: BulkRunnerDelete, options?: any): AxiosPromise<void> {
            return localVarFp.bulkDeleteRunner(bulkRunnerDelete, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {BulkRunnerActiveStatus} [bulkRunnerActiveStatus] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkSetRunnerActiveStatus(bulkRunnerActiveStatus?: BulkRunnerActiveStatus, options?: any): AxiosPromise<boolean> {
            return localVarFp.bulkSetRunnerActiveStatus(bulkRunnerActiveStatus, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} runnerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRunner(runnerId: number, options?: any): AxiosPromise<void> {
            return localVarFp.deleteRunner(runnerId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} groupId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupRunners(groupId: number, options?: any): AxiosPromise<Array<Runner>> {
            return localVarFp.getGroupRunners(groupId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} runnerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRunnerJobHistory(runnerId: number, options?: any): AxiosPromise<Array<Job>> {
            return localVarFp.getRunnerJobHistory(runnerId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} runnerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSingleRunner(runnerId: number, options?: any): AxiosPromise<Runner> {
            return localVarFp.getSingleRunner(runnerId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} runnerId 
         * @param {boolean} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setRunnerActiveStatus(runnerId: number, body?: boolean, options?: any): AxiosPromise<boolean> {
            return localVarFp.setRunnerActiveStatus(runnerId, body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RunnerApi - object-oriented interface
 * @export
 * @class RunnerApi
 * @extends {BaseAPI}
 */
export class RunnerApi extends BaseAPI {
    /**
     * 
     * @param {BulkRunnerDelete} [bulkRunnerDelete] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunnerApi
     */
    public bulkDeleteRunner(bulkRunnerDelete?: BulkRunnerDelete, options?: AxiosRequestConfig) {
        return RunnerApiFp(this.configuration).bulkDeleteRunner(bulkRunnerDelete, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {BulkRunnerActiveStatus} [bulkRunnerActiveStatus] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunnerApi
     */
    public bulkSetRunnerActiveStatus(bulkRunnerActiveStatus?: BulkRunnerActiveStatus, options?: AxiosRequestConfig) {
        return RunnerApiFp(this.configuration).bulkSetRunnerActiveStatus(bulkRunnerActiveStatus, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} runnerId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunnerApi
     */
    public deleteRunner(runnerId: number, options?: AxiosRequestConfig) {
        return RunnerApiFp(this.configuration).deleteRunner(runnerId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} groupId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunnerApi
     */
    public getGroupRunners(groupId: number, options?: AxiosRequestConfig) {
        return RunnerApiFp(this.configuration).getGroupRunners(groupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} runnerId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunnerApi
     */
    public getRunnerJobHistory(runnerId: number, options?: AxiosRequestConfig) {
        return RunnerApiFp(this.configuration).getRunnerJobHistory(runnerId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} runnerId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunnerApi
     */
    public getSingleRunner(runnerId: number, options?: AxiosRequestConfig) {
        return RunnerApiFp(this.configuration).getSingleRunner(runnerId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} runnerId 
     * @param {boolean} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunnerApi
     */
    public setRunnerActiveStatus(runnerId: number, body?: boolean, options?: AxiosRequestConfig) {
        return RunnerApiFp(this.configuration).setRunnerActiveStatus(runnerId, body, options).then((request) => request(this.axios, this.basePath));
    }
}


